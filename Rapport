Rapport de Projet : CardYard (2024-2025)

1. Description de l'équipe
Membres :Oumeyma (Développement principal, affichage, carte.c)
         Antoine (Tests, corrections bugs, affichage couleur, jeu.c, main.c)
         Ethan (Makefile, nettoyage du code, sécurisation des entrées)




2. Description du projet

Le projet CardYard est un jeu de cartes multijoueur sous forme de programme C, respectant le cahier des charges fourni par le support de TD.
But du jeu : Chaque joueur doit minimiser la somme des valeurs de ses cartes à la fin de la partie.
Règles principales :
     Chaque joueur possède des cartes cachées + une défausse visible.
     Tour par tour : piocher ou prendre une carte visible d'une défausse.
     Un joueur qui rend toutes ses cartes visibles enclenche la fin de partie.




3. Organisation et rôles

Nous avons adopté une méthodologie agile avec réunions régulières :

Oumeyma : Conception des fonctions d'affichage, création du deck, gestion des cartes (carte.c).
Antoine : Réglages des bugs, amélioration des couleurs et ergonomie (jeu.c et main.c).
Ethan : Amélioration du Makefile, sécurisation des entrées avec better_scan_int et better_scan_str, nettoyage global du code.

Communication : GitHub pour la version, Whatsapp pour le suivi.




4. Journal de bord (extrait)

11 avril :
Première réunion, séparation du code en modules. Début des fonctions de création et mélange du deck.

Vacances :
Beaucoup d'avancées grâce à Oumeyma : affichage pioche, défausse, cartes des joueurs (carte.c finalisé).

Semaine de la rentrée & séance du 2 mai :
Travail d'équipe en séance : jeu.c et main.c quasi terminés.

8 mai :
Ethan : création des fonctions sécurisées pour scanf.

9 mai :
Séance de finalisation : Ethan finalise le Makefile, Antoine et Oumeyma corrigent les bugs et améliorent l'affichage. Problème identifié avec la détection de fin de partie (jeu qui tourne une fois de trop, non résolu par manque de temps). Abandon du projet d'affichage graphique trop complexe.




5. Problèmes rencontrés et solutions

Au cours de la réalisation du projet, plusieurs difficultés ont été rencontrées :
- La gestion des pointeurs et des allocations dynamiques a nécessité une grande rigueur pour éviter les erreurs de segmentation et les fuites mémoire.
- La synchronisation des accès aux structures de données (deck, pile, joueurs) a demandé un important travail d’organisation et de validation.
- L’implémentation de la détection de fin de partie a été complexe. Malgré plusieurs tentatives, un léger décalage subsiste, provoquant parfois un tour supplémentaire non prévu.
- L’intégration du Makefile et la gestion des dépendances entre les fichiers source ont également demandé du temps et des ajustements.

Ces difficultés ont été surmontées grâce au travail d’équipe, aux tests réguliers et à une approche progressive et modulaire du développement.
Nous avons donc décidé d'améliorer l'expérience utilisateur en créant un affichage stylisé avec des cadres ASCII pour représenter les cartes. Cela a nécessité plusieurs itérations pour obtenir un rendu propre et cohérent, notamment en alignant correctement les indices, les bords des cartes et en choisissant des couleurs adaptées selon les valeurs des cartes (valeurs négatives en vert, faibles en bleu, moyennes en jaune, fortes en rouge).
Une réflexion a aussi été menée pour intégrer des symboles ou emojis dans l'affichage afin de le rendre encore plus esthétique, mais cela a été abandonné car trop complexe à intégrer et à maîtriser dans le temps imparti.
Le résultat final est un affichage coloré, clair et suffisamment ergonomique pour une utilisation en terminal.





7. Travail restant / Améliorations possibles

Le principal axe d’amélioration identifié concerne l’affichage. Une optimisation de l’alignement et du rendu des cartes pourrait encore améliorer la lisibilité du jeu. De plus, une meilleure gestion des tailles d’écran et du centrage du contenu offrirait une expérience utilisateur plus agréable.




8. Conclusion

Le projet est stable, fonctionnel et respecte la majorité du cahier des charges.
Objectifs atteints :
   Modularité et clarté du code
   Application robuste sans crash
   Affichage ergonomique malgré les contraintes du terminal

Pistes de perfectionnement :
  Améliorer le confort utilisateur
  Améliorer l'affichage

Ce projet a permis de renforcer nos compétences en C, gestion de projet et travail collaboratif.
